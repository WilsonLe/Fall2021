void Graph::prim(int root)
{
	// The total number of edges in the graph
	int numEdges = 0;

	for (Vertex *vertex : adjList)
	{
		vertex->minWeight = INT_MAX;
		vertex->parent = nullptr;
		numEdges += vertex->edges.size();
	}

	adjList[root]->minWeight = 0;

	// We will have at maximum O(E) vertices in the priority queue
	MinPriorityQueue<Vertex> pq(numEdges / 2);
	pq.insert(adjList[root]);

	// If the vertex i is already in the MST, then inMST[i] = true, false otherwise.
	vector<bool> inMST(adjList.size(), false);

	while (!pq.empty())
	{
		Vertex *top = pq.extractMin();
		// If the vertex has already been put into the MST, then skip this vertex.
		if (inMST[top->key])
			continue;
		inMST[top->key] = true;

		for (Edge *edge : top->edges)
		{
			if (!inMST[edge->dest->key] && edge->weight < edge->dest->minWeight)
			{
				edge->dest->minWeight = edge->weight;
				edge->dest->parent = top;
				// Instead of calling decreaseKey and deal with indexes, just insert the vertex again and let the pq put it at the right place
				pq.insert(edge->dest);
			}
		}
	}

	for (Vertex *vertex : adjList)
	{
		if (vertex->parent == nullptr && vertex != adjList[root])
		{
			cout << "The graph is disconnected. Therefore, prim operation is not possible." << '\n';
			return;
		}
	}

	for (Vertex *vertex : adjList)
	{
		if (vertex->parent)
		{
			cout << vertex->parent->key << " " << vertex->key << " " << vertex->minWeight << '\n';
		}
	}
}
